#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# This script performs Singular Value Decomposition of matrix X of shape
# (m x n) with m >> n
# 
# Reference: 
# "RECURSIVE CALCULATION OF DOMINANT SINGULAR SUBSPACES"
# Y. CHAHLAOUI, K. GALLIVAN, AND P. VAN DOOREN

# INPUT PARAMETERS:
# -----------------------------------------------------------------------------
# NAME   TYPE   DEFAULT  MEANING
# -----------------------------------------------------------------------------
# X      matrix   ---    input matrix to be factorized
# -----------------------------------------------------------------------------

# OUTPUT:
# -----------------------------------------------------------------------------
# NAME   TYPE    MEANING
# -----------------------------------------------------------------------------
# U      matrix  left singular matrix
# S      matrix  vector containing singular values
# V      matrix  right singular matrix
# -----------------------------------------------------------------------------

source("scalable_linalg/qr.dml") as qr

X = read($1);

SingularValueDecomposition = function(matrix[double] X, int nb)
  return (matrix[double] U, matrix[double] S, matrix[double] temp) {

#  Xt = t(X)
#  c = ncol(Xt)
#  r = nrow(Xt)
  
# Ni = as.integer(c/nb)
# if (Ni < r) {
#   # TODO figure out optimal value of nb
#   print("nb too small")
#  }
  
  [Q, R] = qr::QR(X, nb); //scalable qr decomposition
  
  [U, S, V] = svd(R); //computes svd locally
  
}

 write(U, $2);
 write(S, $3);
