#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------


# ----------------------------------------------------
# Modal selection for Gaussian Process Classification
# ----------------------------------------------------

source("model_selection/mode.dml") as mode

n = 10;
d = 5;

X = 10 * rand(rows=n, cols=d);
y = 0.2 * rand(rows=n, cols=1); # "0.2" is the standard deviation
lh = matrix(0, rows=n, cols=1);
K = rand(rows=3, cols=3, min=0.000000001, max=1);


# likelihood, mean & covariance are the structure of theta(i.e, of hyperparameters)

gpc = function (matrix[double] X, matrix[double] y, matrix[double] theta, matrix[double] lh)
  return (matrix[double] Z, matrix[double] dZ) {

  /*
   * INPUT:
   * - X     : inputs,
   * - y     : targets,
   * - theta : hyperparameters
   * - lh    : likelihood function
   *
   * OUTPUT:
   * - Z     : log marginal likelihood
   * - dZ    : partial derivative
   *
   */

# ------

  # 2. compute K
  K = rand(rows=10, cols=10, min=0.000000001, max=1);

  # 3. f = mode( K, y, p(y|f) )
  [f, lmlh, a] = mode::mode(K, y, lh);

  # take
  D = 1 / (1+exp(-f)); # operation over each element of f
  ONES = matrix(1, rows=nrow(D), cols=ncol(D));
  I = diag(matrix(1, rows=nrow(K), cols=1));

  # 4. W = - ∇∇log p(y|f)
  # W = D %*% (ONES-D); # W has to be a matrix
  W = D %*% (1-D);
  W_sq = W ^ 0.5;

  # 5. L = cholesky( I + W^0.5 K W^0.5 )
  L = cholesky( I + W^0.5 %*% K %*% W^0.5 ); # here I, is the identity matrix

  llh = log(lh);

  # 6. Z = - 0.5 t(a) f + log p(y|f) - Σ log( diag (L) )
  Z = - 0.5 * t(a) %*% f + llh - sum( log(diag(L)) );

  # 7. R = W^0.5 t(L) \ (L \ W^0.5)
  # R = W^0.5 (I + W^0.5 K W^0.5)^-1 W^0.5
  R_tmp = solve(L, W_sq);
  R = W^0.5 %*% solve( t(L), R_tmp );

# ------

  # 8. C = L \ (W^0.5 K)
  C = solve( L, W^0.5 %*% K );

  # 9. S2 = - 0.5 diag( diag(K) - diag(t(C) C)) ∇∇∇log p(y|f)
  # S2 = - 0.5 * diag( diag(K) - diag(t(C) %*% C) ) %*% ( D %*% (ONES - D) %*% (ONES - 2*D) );
  S2 = - 0.5 * diag( diag(K) - diag(t(C) %*% C) ) %*% ( D %*% (1 - D) %*% (1 - 2*D) );

  # 10. loop starts now

  for (j in 1:nrow(theta)) {

    # 11. C = ∂K / ∂θj  # compute derivative, matrix from X and θ
    # C = dK # derivate of covariance matrix wrt to j th hyperparameter
    C = K[10, j]; # TODO

    # 12.
    S1 = 0.5 * t(a) %*% C %*% a - 0.5 t(R %*% C)

    # 13. b = C ∇log p(y|f)
    b = C %*% D;

    # 14. S3 = b - K R b
    S3 = b - K %*% R %*% b;

    # 15. ∇jZ = S1 + t(S2) %*% S3
    dZ = S1 + t(S2) %*% S3

  }

# ------

}

